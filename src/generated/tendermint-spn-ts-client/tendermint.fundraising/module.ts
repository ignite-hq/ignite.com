// Generated by Ignite ignite.com/cli

import { StdFee } from '@cosmjs/launchpad'
import { SigningStargateClient, DeliverTxResponse } from '@cosmjs/stargate'
import { EncodeObject } from '@cosmjs/proto-signing'

import { Api } from './rest'
import { MsgCreateBatchAuction } from './types/fundraising/tx'
import { MsgCancelAuction } from './types/fundraising/tx'
import { MsgPlaceBid } from './types/fundraising/tx'
import { MsgModifyBid } from './types/fundraising/tx'
import { MsgAddAllowedBidder } from './types/fundraising/tx'
import { MsgCreateFixedPriceAuction } from './types/fundraising/tx'

type sendMsgCreateBatchAuctionParams = {
  value: MsgCreateBatchAuction
  fee?: StdFee
  memo?: string
}

type sendMsgCancelAuctionParams = {
  value: MsgCancelAuction
  fee?: StdFee
  memo?: string
}

type sendMsgPlaceBidParams = {
  value: MsgPlaceBid
  fee?: StdFee
  memo?: string
}

type sendMsgModifyBidParams = {
  value: MsgModifyBid
  fee?: StdFee
  memo?: string
}

type sendMsgAddAllowedBidderParams = {
  value: MsgAddAllowedBidder
  fee?: StdFee
  memo?: string
}

type sendMsgCreateFixedPriceAuctionParams = {
  value: MsgCreateFixedPriceAuction
  fee?: StdFee
  memo?: string
}

type msgCreateBatchAuctionParams = {
  value: MsgCreateBatchAuction
}

type msgCancelAuctionParams = {
  value: MsgCancelAuction
}

type msgPlaceBidParams = {
  value: MsgPlaceBid
}

type msgModifyBidParams = {
  value: MsgModifyBid
}

type msgAddAllowedBidderParams = {
  value: MsgAddAllowedBidder
}

type msgCreateFixedPriceAuctionParams = {
  value: MsgCreateFixedPriceAuction
}

class Module extends Api<any> {
  private _client: SigningStargateClient
  private _addr: string

  constructor(baseUrl: string) {
    super({
      baseUrl
    })
  }

  public withSigner(client: SigningStargateClient, _addr: string) {
    this._client = client
    this._addr = _addr
  }

  public noSigner() {
    this._client = undefined
    this._addr = undefined
  }

  async sendMsgCreateBatchAuction({
    value,
    fee,
    memo
  }: sendMsgCreateBatchAuctionParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgCreateBatchAuction: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgCreateBatchAuction: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgCreateBatchAuction({
        value: MsgCreateBatchAuction.fromPartial(value)
      })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgCreateBatchAuction: Could not broadcast Tx: ' +
          e.message
      )
    }
  }

  async sendMsgCancelAuction({
    value,
    fee,
    memo
  }: sendMsgCancelAuctionParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgCancelAuction: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgCancelAuction: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgCancelAuction({
        value: MsgCancelAuction.fromPartial(value)
      })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgCancelAuction: Could not broadcast Tx: ' + e.message
      )
    }
  }

  async sendMsgPlaceBid({
    value,
    fee,
    memo
  }: sendMsgPlaceBidParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgPlaceBid: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgPlaceBid: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgPlaceBid({ value: MsgPlaceBid.fromPartial(value) })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgPlaceBid: Could not broadcast Tx: ' + e.message
      )
    }
  }

  async sendMsgModifyBid({
    value,
    fee,
    memo
  }: sendMsgModifyBidParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgModifyBid: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgModifyBid: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgModifyBid({ value: MsgModifyBid.fromPartial(value) })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgModifyBid: Could not broadcast Tx: ' + e.message
      )
    }
  }

  async sendMsgAddAllowedBidder({
    value,
    fee,
    memo
  }: sendMsgAddAllowedBidderParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgAddAllowedBidder: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgAddAllowedBidder: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgAddAllowedBidder({
        value: MsgAddAllowedBidder.fromPartial(value)
      })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgAddAllowedBidder: Could not broadcast Tx: ' + e.message
      )
    }
  }

  async sendMsgCreateFixedPriceAuction({
    value,
    fee,
    memo
  }: sendMsgCreateFixedPriceAuctionParams): Promise<DeliverTxResponse> {
    if (!this._client) {
      throw new Error(
        'TxClient:sendMsgCreateFixedPriceAuction: Unable to sign Tx. Signer is not present.'
      )
    }
    if (!this._addr) {
      throw new Error(
        'TxClient:sendMsgCreateFixedPriceAuction: Unable to sign Tx. Address is not present.'
      )
    }
    try {
      let msg = this.msgCreateFixedPriceAuction({
        value: MsgCreateFixedPriceAuction.fromPartial(value)
      })
      return await this._client.signAndBroadcast(
        this._addr,
        [msg],
        fee ? fee : { amount: [], gas: '200000' },
        memo
      )
    } catch (e: any) {
      throw new Error(
        'TxClient:sendMsgCreateFixedPriceAuction: Could not broadcast Tx: ' +
          e.message
      )
    }
  }

  msgCreateBatchAuction({ value }: msgCreateBatchAuctionParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgCreateBatchAuction',
        value: MsgCreateBatchAuction.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgCreateBatchAuction: Could not create message: ' + e.message
      )
    }
  }

  msgCancelAuction({ value }: msgCancelAuctionParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgCancelAuction',
        value: MsgCancelAuction.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgCancelAuction: Could not create message: ' + e.message
      )
    }
  }

  msgPlaceBid({ value }: msgPlaceBidParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgPlaceBid',
        value: MsgPlaceBid.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgPlaceBid: Could not create message: ' + e.message
      )
    }
  }

  msgModifyBid({ value }: msgModifyBidParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgModifyBid',
        value: MsgModifyBid.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgModifyBid: Could not create message: ' + e.message
      )
    }
  }

  msgAddAllowedBidder({ value }: msgAddAllowedBidderParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgAddAllowedBidder',
        value: MsgAddAllowedBidder.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgAddAllowedBidder: Could not create message: ' + e.message
      )
    }
  }

  msgCreateFixedPriceAuction({
    value
  }: msgCreateFixedPriceAuctionParams): EncodeObject {
    try {
      return {
        typeUrl: '/tendermint.fundraising.MsgCreateFixedPriceAuction',
        value: MsgCreateFixedPriceAuction.fromPartial(value)
      }
    } catch (e: any) {
      throw new Error(
        'TxClient:MsgCreateFixedPriceAuction: Could not create message: ' +
          e.message
      )
    }
  }
}

export default Module
